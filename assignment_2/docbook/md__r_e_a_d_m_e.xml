<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_md__r_e_a_d_m_e" xml:lang="en-US">

<para>Done by: <literallayout><computeroutput>1. Arunachala Amuda Murugan (2021A7PS0205H)
2. Ayush Bhauwala (2021A7PS0180H)
3. Suryansh Chandola (2021A7PS0058H)
</computeroutput></literallayout> </para>
<section xml:id="_md__r_e_a_d_m_e_1autotoc_md1">
<title>Algorithm</title>

<para><orderedlist>
<listitem>
<para>The proof is taken as input line by line (either input @ stdin or from a file using <computeroutput>&lt;</computeroutput>).</para>
</listitem><listitem>
<para>The split function is used to split the given propositional logic formula, into 2 parts at the root of the formula</para>
</listitem><listitem>
<para>The propostional logic formula entered as input is added to a vector&lt;string&gt;.</para>
</listitem><listitem>
<para>A vector that stores the parts of an input line (propositional logic formula and proof rule used) is also created.</para>
</listitem><listitem>
<para>Based on the proof rule used, the appropriate function to check the validity of the rule is called.</para>
</listitem><listitem>
<para>The function runs as long as it reads valid proof lines or if it breaks out at an invalid line.</para>
</listitem></orderedlist>
</para>
</section>
<section xml:id="_md__r_e_a_d_m_e_1autotoc_md2">
<title>Example Runs</title>
<section xml:id="_md__r_e_a_d_m_e_1autotoc_md3">
<title>Example 1:</title>

<para><literallayout><computeroutput>15
(((a*b)&gt;(c*d))&gt;((~e*~f)&gt;(~g+~h)))/P
((a*b)&gt;(c*d))/P
(a*b)/P
(~e*~f)/P
((~e*~f)&gt;(~g+~h))/&gt;e/1/2
(~g+~h)/&gt;e/5/4
(c*d)/&gt;e/2/3
c/*e1/7
d/*e2/7
a/*e1/3
b/*e2/3
(a*b)/*i/10/11
(c*(a*b))/*i/8/12
(d*(c*(a*b)))/*i/9/13
((d*(c*(a*b)))+~i)/+i1/14
</computeroutput></literallayout></para>

<para><emphasis role="bold">Output</emphasis> :</para>

<para><literallayout><computeroutput>Valid&#32;Proof
</computeroutput></literallayout></para>
</section>
<section xml:id="_md__r_e_a_d_m_e_1autotoc_md4">
<title>Example 2:</title>

<para><literallayout><computeroutput>4
(~a&gt;b)/P
(b&gt;c)/P
~c/P
~b/MT/2/3
~a/MT/1/4
</computeroutput></literallayout></para>

<para><emphasis role="bold">Output</emphasis> :</para>

<para><literallayout><computeroutput>Invalid&#32;Proof
</computeroutput></literallayout></para>
</section>
</section>
<section xml:id="_md__r_e_a_d_m_e_1autotoc_md5">
<title>For the implementation of other rules:</title>

<para><orderedlist>
<listitem>
<para>To implement scopes of boxes we will aditionally need two data structures. A pair&lt;string, int&gt; where the integer decalres the scope of the box and a map&lt;int, bool&gt; where we decalre whether the scope has ended or nor for a given number.</para>
</listitem><listitem>
<para>Any line can use other lines above it as long as its scope is &gt;= the scope of the line as the scope referred to has not been closed (false in map).</para>
</listitem><listitem>
<para>The same scope number should never be used twice, so it can easily be implemented/assigned using a counter.</para>
</listitem></orderedlist>
</para>

<para>For example, consider the following proof:</para>

<para>(using <computeroutput>A</computeroutput> for assumption)</para>

<para><literallayout><computeroutput>1.&#32;(p&gt;q)/P
2.&#32;~q/A
3.&#32;~p/MT/1/2
4.&#32;(~q&gt;~p)/&gt;i/2-3
</computeroutput></literallayout></para>

<para>The values vector will look like</para>

<para><literallayout><computeroutput>{
&#32;&#32;&#32;&#32;&lt;(p&gt;q),&#32;0&gt;,
&#32;&#32;&#32;&#32;&lt;~q,&#32;1&gt;,
&#32;&#32;&#32;&#32;&lt;~p,&#32;1&gt;,
&#32;&#32;&#32;&#32;&lt;(~q&gt;~p),&#32;0&gt;
}
</computeroutput></literallayout></para>

<para>Here, lines with scope 1 can access lines with scope 0 or 1 while lines with scope 0 can access lines with scope 0 only. And once the scope of 1 is over we assign it <computeroutput>false</computeroutput> in the map. </para>
</section>
</section>
